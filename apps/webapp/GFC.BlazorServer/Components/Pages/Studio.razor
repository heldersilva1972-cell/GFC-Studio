@page "/studio"
@page "/studio/{PageId:int}"
@layout GFC.BlazorServer.Components.Layout.StudioLayout
@using System.Text.Json
@using GFC.Core.Models
@using GFC.Core.Interfaces
@using GFC.BlazorServer.Services
@using GFC.BlazorServer.Components.Shared
@inject IJSRuntime JSRuntime
@inject IStudioService StudioService
@inject IStudioAutoSaveService AutoSaveService
@inject IPageService PageService
@inject ITemplateService TemplateService
@inject IContentIngestionService ContentIngestionService
@inject ILogger<Studio> Logger
@inject NavigationManager NavigationManager
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IConfiguration Configuration

<div class="studio-container">
    <div class="top-command-bar">
        <button class="btn btn-primary" @onclick="AddSection">Add Section</button>
        <button class="btn btn-success" @onclick="() => SaveDraft()">Save Version @(latestVersion > 0 ? $" (v{latestVersion})" : "")</button>
        <button class="btn btn-info" @onclick="PublishPage">Publish</button>

        <div class="save-status @saveStatus.ToString().ToLower()">
            @saveStatusText
        </div>
        
        <div class="dropdown d-inline-block ms-3">
            <button class="btn btn-outline-light dropdown-toggle" type="button" @onclick="ToggleHistory">
                History
            </button>
            @if (showHistory)
            {
                <div class="dropdown-menu show" style="max-height: 400px; overflow-y: auto; width: 350px;">
                    @foreach (var h in draftHistory)
                    {
                        <div class="px-2 py-1 border-bottom">
                            <div class="d-flex justify-content-between align-items-center">
                                <strong>v@h.Version - @(h.ChangeDescription ?? "Auto-save")</strong>
                                <button class="btn btn-sm btn-outline-primary" @onclick="() => LoadDraft(h)">
                                    Rollback
                                </button>
                            </div>
                            <small class="text-muted">@h.CreatedAt.ToLocalTime().ToString("g") by @h.CreatedBy</small>
                        </div>
                    }
                </div>
            }
        </div>
    </div>

@if (showNewPageModal)
{
    <NewPageModal ExistingPages="allPages" OnCancel="() => showNewPageModal = false" OnConfirm="CreateNewPage" ErrorMessage="@_newPageErrorMessage" />
}



    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger m-3">
            <h4>Error Loading Studio</h4>
            <p>@errorMessage</p>
            <pre>@errorDetails</pre>
        </div>
    }

    <div class="studio-workspace">
        <div class="left-toolbox @(isLeftPanelCollapsed ? "collapsed" : "")">
            <div class="panel-header">
                <div class="toolbox-tabs">
                    <button class="tab-button @(activeToolboxTab == "templates" ? "active" : "")" @onclick='() => activeToolboxTab = "templates"'>Templates</button>
                    <button class="tab-button @(activeToolboxTab == "elements" ? "active" : "")" @onclick='() => activeToolboxTab = "elements"'>Elements</button>
                </div>
                <div class="collapse-handle" @onclick="() => isLeftPanelCollapsed = !isLeftPanelCollapsed">
                    @(isLeftPanelCollapsed ? "▶" : "◀")
                </div>
            </div>
            <div class="toolbox-content">
                @if (activeToolboxTab == "templates")
                {
                    <div class="template-filter mb-2">
                        <select class="form-control form-control-sm" @onchange="FilterTemplates">
                            <option value="">All Categories</option>
                            @foreach (var category in templateCategories)
                            {
                                <option value="@category">@category</option>
                            }
                        </select>
                    </div>
                    <div class="template-list">
                        @foreach (var template in filteredTemplates)
                        {
                            <div class="template-item" draggable="true" @ondragstart="@(() => HandleDragStart(template))">
                                <img src="@(template.ThumbnailUrl ?? "https://via.placeholder.com/300x150?text=" + template.Category)" alt="@template.Name" class="template-thumb" />
                                <div class="template-name">@template.Name</div>
                                <button class="btn btn-sm btn-danger template-delete-btn" @onclick="() => DeleteTemplate(template.Id)">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        }
                    </div>
                }
                @if (activeToolboxTab == "elements")
                {
                    <p>Elements toolbox coming soon!</p>
                }
            </div>
        </div>

        <div class="canvas-container @($"viewport-{currentViewport}")">
            <div class="center-canvas" @ondrop="HandleDrop" @ondragover:preventDefault="true">

                @foreach (var item in sections)
                {
                    <div class="studio-section @(selectedSection == item ? "selected" : "")" data-id="@item.ClientId" @onclick="() => SelectSection(item)">
                        <div class="section-toolbar">
                            <button class="btn btn-sm btn-outline-light" @onclick="() => OpenSaveAsTemplateModal(item)">Save as Template</button>
                        </div>
                        <p contenteditable="true" @oninput="(e) => { item.Content = e.Value.ToString(); MarkAsDirty(); }">@item.Content</p>
                    </div>
                }
            </div>
        </div>
        <div class="right-inspector">
            <StudioWizard @ref="studioWizard" TargetSection="selectedSection" OnContentFixed="@(args => HandleContentFixed(args.newContent, args.fixName))" />
            @if (!string.IsNullOrEmpty(lastWizardAction))
            {
                <button class="btn btn-sm btn-link" @onclick="UndoLastAction">Undo "@lastWizardAction"</button>
            }
        </div>
    </div>
    <div class="animation-orchestrator">
        @if (selectedSection != null)
        {
            <h5>Animation Timeline for: "@selectedSection.Title"</h5>
            <div class="timeline-bar" @ref="_timelineElement">
                @for (int i = 0; i <= 5; i++)
                {
                    <div class="timeline-tick" style="left: @(i * 20)%"></div>
                }
                @if (!string.IsNullOrEmpty(_previewUrl))
                {
                    <iframe @ref="_previewIframe" src="@_previewUrl" class="studio-iframe" allow="clipboard-write"></iframe>
                }
                else
                {
                    <div class="alert alert-info">Loading Preview...</div>
                }
           </div>       
        }

        <div class="right-inspector @(isRightPanelCollapsed ? "collapsed" : "")">
             <div class="panel-header">
                 <div class="collapse-handle" @onclick="() => isRightPanelCollapsed = !isRightPanelCollapsed">
                     @(isRightPanelCollapsed ? "◀" : "▶")
                 </div>
                 <h5 class="m-0 ms-2">Inspector</h5>
             </div>
             <div class="inspector-content">
                 <StudioWizard TargetSection="selectedSection" OnPropertyChanged="HandlePropertyChange" />
             </div>
         </div>
     <AnimationOrchestrator TargetSection="selectedSection" OnAnimationSettingsChanged="HandleAnimationSettingsChanged" />
    </div>
</div>
@if (showSaveAsTemplateModal)
{
    <div class="modal fade show" style="display: block;" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Save Section as Template</h5>
                    <button type="button" class="close" @onclick="CloseSaveAsTemplateModal">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="templateName">Template Name</label>
                        <input type="text" class="form-control" id="templateName" @bind="newTemplateName" />
                    </div>
                    <div class="form-group">
                        <label for="templateCategory">Category</label>
                        <input type="text" class="form-control" id="templateCategory" @bind="newTemplateCategory" />
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CloseSaveAsTemplateModal">Close</button>
                    <button type="button" class="btn btn-primary" @onclick="SaveTemplate">Save Template</button>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-backdrop fade show"></div>
}

@if (showSaveVersionModal)
{
    <div class="modal fade show" style="display: block;" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Save Named Version</h5>
                    <button type="button" class="close" @onclick="() => showSaveVersionModal = false">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="versionDescription">Description (optional)</label>
                        <input type="text" class="form-control" id="versionDescription" @bind="versionDescription" placeholder="e.g., Before Christmas Redesign" />
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="() => showSaveVersionModal = false">Cancel</button>
                    <button type="button" class="btn btn-primary" @onclick="() => SaveDraft(true)">Save Version</button>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-backdrop fade show"></div>
}

@if (showUrlImportModal)
{
    <div class="modal fade show" style="display: block;" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Import from URL</h5>
                    <button type="button" class="close" @onclick="CloseImportModal">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    @if (isImporting)
                    {
                        <div class="text-center">
                            <div class="spinner-border" role="status">
                                <span class="sr-only">Loading...</span>
                            </div>
                            <p>Scraping content, please wait...</p>
                        </div>
                    }
                    else
                    {
                        @if (!string.IsNullOrEmpty(importErrorMessage))
                        {
                            <div class="alert alert-danger">@importErrorMessage</div>
                        }
                        <div class="form-group">
                            <label for="urlInput">URL to Scrape</label>
                            <input type="text" class="form-control" id="urlInput" @bind="urlToImport" />
                        </div>
                    }
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CloseImportModal">Cancel</button>
                    <button type="button" class="btn btn-primary" @onclick="ImportFromUrl">Import</button>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-backdrop fade show"></div>
}

@if (showPublishModal)
{
    <div class="modal fade show" style="display: block;" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Confirm Publish</h5>
                    <button type="button" class="close" @onclick="() => showPublishModal = false">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to publish your changes to the live website? This action cannot be undone.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="() => showPublishModal = false">Cancel</button>
                    <button type="button" class="btn btn-primary" @onclick="ConfirmPublish">Publish</button>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-backdrop fade show"></div>
}

@code {
    public enum SaveStatus
    {
        Saved,
        Saving,
        Error
    }

    [Parameter]
    public int PageId { get; set; }

    private bool showUrlImportModal = false;
    private string urlToImport = "";
    private bool isImporting = false;
    private string importErrorMessage = "";

    private bool isLeftPanelCollapsed = false;
    private bool isRightPanelCollapsed = false;

    private bool showNewPageModal = false;
    private List<StudioPage> allPages = new();
    private StudioPage currentPage;
    private StudioDraft draft;
    private List<StudioSection> sections = new();
    private StudioSection selectedSection;
    private List<StudioTemplate> templates = new();
    private List<StudioTemplate> filteredTemplates = new();
    private List<string> templateCategories = new();
    private string selectedTemplateCategory = "";
    private string activeToolboxTab = "templates";
    private StudioSection sectionToSave;
    private bool showSaveAsTemplateModal = false;
    private string newTemplateName = "";
    private string newTemplateCategory = "";
    private string lastWizardAction = "";
    private bool showHistory = false;
    private List<StudioDraft> draftHistory = new();
    private StudioSection lastUndoState;
    private StudioTemplate draggedTemplate;
    private void HandleAnimationSettingsChanged(string newSettings)
    {
        if (selectedSection != null)
        {
            selectedSection.AnimationSettings = newSettings;
            StateHasChanged();
        }
    }

    private AnimationSettings currentAnimationSettings = new();
    private StudioWizard studioWizard;
    private List<StudioWizard.WizardWarning> wizardWarnings = new();
    private ElementReference _previewIframe;
    private string _previewUrl;
    private string _pageSlug;
    private string currentUserName;
    private SaveStatus saveStatus = SaveStatus.Saved;
    private string saveStatusText = "All changes saved.";
    private int latestVersion = 0;
    private bool showPublishModal = false;
    private bool showSaveVersionModal = false;
    private string versionDescription = string.Empty;

    protected override void OnParametersSet()
    {
        if (studioWizard != null)
        {
            wizardWarnings = studioWizard.Warnings;
        }
    }

    private void HandleContentFixed(string newContent, string fixName)
    {
        if (selectedSection != null)
        {
            lastUndoState = new StudioSection { Content = selectedSection.Content };
            selectedSection.Content = newContent;
            lastWizardAction = $"Auto-Fix: {fixName}";
            MarkAsDirty();
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void SetSelectedSection(StudioSection section)
    {
        selectedSection = section;
        StateHasChanged();
    }

    private async Task HandlePropertyChange((string sectionId, string propertyName, object propertyValue) args)
    {
        var styleUpdate = new Dictionary<string, object>
        {
            { args.propertyName, args.propertyValue }
        };

        if (_previewIframe.Context != null)
        {
            await JSRuntime.InvokeVoidAsync("studioInterop.updateStyleInPreview", _previewIframe, args.sectionId, styleUpdate);
        }
    }

    private void UndoLastAction()
    {
        if (selectedSection != null && lastUndoState != null)
        {
            selectedSection.Content = lastUndoState.Content;
            selectedSection.AnimationSettingsJson = lastUndoState.AnimationSettingsJson;
            lastWizardAction = "";
            lastUndoState = null;
            MarkAsDirty();
            StateHasChanged();
        }
    }

    private void ToggleHistory() => showHistory = !showHistory;

    private void SelectSection(StudioSection section)
    {
        selectedSection = section;

      if (!string.IsNullOrEmpty(selectedSection.AnimationSettingsJson))
        {
            try
            {
                currentAnimationSettings = JsonSerializer.Deserialize<AnimationSettings>(selectedSection.AnimationSettingsJson) ?? new AnimationSettings();
            }
            catch
            {
                currentAnimationSettings = new AnimationSettings();
            }
        }
        else
        {
            currentAnimationSettings = new AnimationSettings();
        }

        // Re-initialize JS interop for the timeline
        JSRuntime.InvokeVoidAsync("animationInterop.initializeTimeline", DotNetObjectReference.Create(this));
        JSRuntime.InvokeVoidAsync("animationScrubbing.initializeScrubbing", _previewIframe);
    }

    private async Task UpdateAnimationSettings()
    {
        if (selectedSection != null)
        {
            selectedSection.AnimationSettingsJson = JsonSerializer.Serialize(currentAnimationSettings);
            await JSRuntime.InvokeVoidAsync("studioInterop.updateAnimation", _previewIframe, selectedSection);
        }
        showHistory = false;
        MarkAsDirty(); // When a user rolls back, it should be saved as a new draft
        StateHasChanged();
    }



    private async Task HandlePageSelected(StudioPage page)
    {
        if (page != null && page.Id != PageId)
        {
            // Update the URL in the browser's address bar without forcing a reload
            NavigationManager.NavigateTo($"/studio/{page.Id}");

            // Now, reload the component's state with the new page's data
            await LoadPageAsync(page.Id);
        }
    }

    private void MarkAsDirty()
    {
        saveStatus = SaveStatus.Saving;
        saveStatusText = "Saving...";
        if (currentUserName != null)
        {
            AutoSaveService.MarkAsDirty(PageId, sections, currentUserName);
        }
    }

    private void AddKeyframe()
    {
        // currentAnimationKeyframes.Add(new AnimationKeyframe { Delay = currentAnimationKeyframes.LastOrDefault()?.Delay + currentAnimationKeyframes.LastOrDefault()?.Duration ?? 0 });
        MarkAsDirty();
    }

    private string _newPageErrorMessage = null;

    private async Task CreateNewPage(StudioPage pageStub)
    {
        _newPageErrorMessage = null;
        try
        {
            var created = await PageService.CreatePageAsync(pageStub.Title);
            allPages.Add(created);
            showNewPageModal = false;
            await HandlePageSelected(created);
        }
        catch (Exception ex)
        {
            _newPageErrorMessage = ex.Message;
        }
    }

    private async Task LoadDraft(StudioDraft selectedDraft)
    {
        draft = selectedDraft;
        if (!string.IsNullOrEmpty(draft.ContentJson))
        {
            sections = JsonSerializer.Deserialize<List<StudioSection>>(draft.ContentJson);
        }
        showHistory = false;
        StateHasChanged();
    }

    private void HandleDragStart(StudioTemplate template)
    {
        draggedTemplate = template;
    }

    private async Task HandleDrop()
    {
        if (draggedTemplate != null)
        {
            var newSection = JsonSerializer.Deserialize<StudioSection>(draggedTemplate.ContentJson);
            newSection.ClientId = Guid.NewGuid();
            newSection.StudioPageId = PageId;
            newSection.PageIndex = sections.Count;

            await JSRuntime.InvokeVoidAsync("studioInterop.sendComponentToPreview", _previewIframe, newSection);

            sections.Add(newSection); // Optimistically add to local state
            draggedTemplate = null;
            MarkAsDirty();
        }
    }

    private void OpenSaveAsTemplateModal(StudioSection section)
    {
        sectionToSave = section;
        newTemplateName = section.Title ?? section.ComponentType;
        newTemplateCategory = "General";
        showSaveAsTemplateModal = true;
    }

    private void CloseSaveAsTemplateModal()
    {
        showSaveAsTemplateModal = false;
        sectionToSave = null;
        newTemplateName = "";
        newTemplateCategory = "";
    }

    private async Task SaveTemplate()
    {
        if (sectionToSave != null && !string.IsNullOrWhiteSpace(newTemplateName) && !string.IsNullOrWhiteSpace(newTemplateCategory))
        {
            var newTemplate = new StudioTemplate
            {
                Name = newTemplateName,
                Category = newTemplateCategory,
                ContentJson = JsonSerializer.Serialize(sectionToSave)
            };
            await TemplateService.CreateTemplateAsync(newTemplate);
            await LoadTemplates();
            CloseSaveAsTemplateModal();
        }
    }
    private string currentViewport = "desktop";
    private string errorMessage;
    private string errorDetails;

    private async Task LoadTemplates()
    {
        templates = await TemplateService.GetAllTemplatesAsync();
        templateCategories = templates.Select(t => t.Category).Distinct().OrderBy(c => c).ToList();
        FilterTemplates(new ChangeEventArgs { Value = "" });
    }

    private void FilterTemplates(ChangeEventArgs e)
    {
        selectedTemplateCategory = e.Value?.ToString() ?? "";
        if (string.IsNullOrEmpty(selectedTemplateCategory))
        {
            filteredTemplates = templates;
        }
        else
        {
            filteredTemplates = templates.Where(t => t.Category == selectedTemplateCategory).ToList();
        }
    }

    private async Task DeleteTemplate(int id)
    {
        await TemplateService.DeleteTemplateAsync(id);
        await LoadTemplates();
    }

    private void setViewport(string viewport)
    {
        currentViewport = viewport;
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && string.IsNullOrEmpty(errorMessage))
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            currentUserName = authState.User.Identity?.Name ?? "System";

            if (PageId == 0)
            {
                var dotNetHelper = DotNetObjectReference.Create(this);
                await JSRuntime.InvokeVoidAsync("studioInterop.setDotNetHelper", dotNetHelper);
                await JSRuntime.InvokeVoidAsync("studioInterop.initializeMessageHandler");
            }

            draft = await StudioService.GetLatestDraftAsync(PageId);
            latestVersion = await AutoSaveService.GetLatestVersionAsync(PageId);

            if (draft != null && !string.IsNullOrEmpty(draft.ContentJson))
            {
                // Sections will be loaded here
            }
        }
        else if (firstRender && !string.IsNullOrEmpty(errorMessage))
        {
             // Log error case
        }

        if (selectedSection != null)
        {
            await JSRuntime.InvokeVoidAsync("animationInterop.initializeTimeline", DotNetObjectReference.Create(this));
            await JSRuntime.InvokeVoidAsync("animationScrubbing.initializeScrubbing", _previewIframe);
        }
    }

    private async Task LoadPageAsync(int pageId)
    {
        errorMessage = null;
        errorDetails = null;
        sections = new();
        draft = null;
        currentPage = null;

        try
        {
            currentPage = await PageService.GetPageAsync(pageId);
            if (currentPage == null)
            {
                errorMessage = "The requested page could not be found.";
                return;
            }

            PageId = pageId; // Update the component's parameter
            _pageSlug = currentPage.Slug;
            var previewUrlBase = Configuration["NEXTJS_PREVIEW_URL"];
            _previewUrl = $"{previewUrlBase}/studio-preview/{_pageSlug}";

            draft = await StudioService.GetLatestDraftAsync(PageId);
            sections = !string.IsNullOrEmpty(draft?.ContentSnapshotJson)
                ? JsonSerializer.Deserialize<List<StudioSection>>(draft.ContentSnapshotJson)
                : new List<StudioSection>();

            await LoadHistory();
            await LoadTemplates(); // Consider if this needs to be reloaded every time
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load page data for page {PageId}", pageId);
            errorMessage = "An unexpected error occurred while loading the page.";
            errorDetails = ex.Message;
        }

        StateHasChanged(); // Ensure the UI updates
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            allPages = await PageService.GetAllPagesAsync();

            var effectivePageId = PageId;
            if (effectivePageId == 0)
            {
                var firstPage = allPages.FirstOrDefault();
                if (firstPage != null)
                {
                    effectivePageId = firstPage.Id;
                    // Update URL without forcing a reload, just to be clean
                    NavigationManager.NavigateTo($"/studio/{effectivePageId}", replace: true);
                }
                else
                {
                    errorMessage = "No pages found. Create a new page to begin.";
                    return;
                }
            }

            await LoadPageAsync(effectivePageId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize Studio");
            errorMessage = $"Studio initialization failed: {ex.Message}";
            errorDetails = ex.StackTrace;
        }
    }

    [JSInvokable]
    public async Task UpdateAnimationTimeline(double delay, double duration)
    {
        currentAnimationSettings.Delay = Math.Round(delay, 2);
        currentAnimationSettings.Duration = Math.Round(duration, 2);
        await UpdateAnimationSettings();
        StateHasChanged();
    }

    private async Task LoadHistory()
    {
        draftHistory = (await StudioService.GetDraftHistoryAsync(PageId)).ToList();
    }

    private async Task SaveDraft(bool fromModal = false)
    {
        if (!fromModal)
        {
            showSaveVersionModal = true;
            return;
        }

        showSaveVersionModal = false;

        try
        {
            saveStatus = SaveStatus.Saving;
            saveStatusText = "Saving manual version...";
            StateHasChanged();

            if (selectedSection != null)
            {
               // Update animation settings logic if needed
            }
            
            var json = JsonSerializer.Serialize(sections);
            draft = await StudioService.SaveDraftAsync(PageId, json, "System", versionDescription); // TODO: Use real user
            versionDescription = string.Empty; // Reset for next time
            
            await LoadHistory();
            latestVersion = await AutoSaveService.GetLatestVersionAsync(PageId);

            saveStatus = SaveStatus.Saved;
            saveStatusText = "Manual version saved.";
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save draft");
            errorMessage = "Failed to save draft: " + ex.Message;
        }
    }

    private async Task PublishPage()
    {
        showPublishModal = true;
    }

    private async Task ConfirmPublish()
    {
        showPublishModal = false;

        try
        {
            if (draft == null || draft.Id == 0)
            {
                await SaveDraft(true);
            }
            
            if (draft != null)
            {
                await StudioService.PublishDraftAsync(draft.Id);
                // After publishing, we might want to refresh the page or show success
                saveStatus = SaveStatus.Saved;
                saveStatusText = "Published successfully!";
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to publish page");
            errorMessage = "Failed to publish page: " + ex.Message;
        }
    }

    private void AddSection()
    {
        var newSection = new StudioSection
        {
            ClientId = Guid.NewGuid(),
            Title = "New Section",
            Content = "New Section",
            PageIndex = sections.Count,
            StudioPageId = PageId,
        };
        sections.Add(newSection);
        MarkAsDirty();
    }

    [JSInvokable]
    public void UpdateSectionOrder(string[] clientIds)
    {
        var newSections = new List<StudioSection>();
        foreach (var id in clientIds)
        {
            var section = sections.First(s => s.ClientId == Guid.Parse(id));
            section.PageIndex = newSections.Count;
            newSections.Add(section);
        }
        sections = newSections;
        MarkAsDirty();
        StateHasChanged();
    }

    private void CloseImportModal()
    {
        showUrlImportModal = false;
        importErrorMessage = "";
        urlToImport = "";
    }

    private async Task ImportFromUrl()
    {
        if (string.IsNullOrWhiteSpace(urlToImport))
        {
            importErrorMessage = "Please enter a URL to import.";
            return;
        }

        isImporting = true;
        importErrorMessage = "";
        StateHasChanged();

        try
        {
            var newSections = await ContentIngestionService.ScrapeUrlAsync(urlToImport);
            if (newSections.Any())
            {
                // Set page index correctly
                int startingIndex = sections.Count;
                foreach (var section in newSections)
                {
                    section.PageIndex = startingIndex++;
                    section.StudioPageId = PageId;
                }
                sections.AddRange(newSections);
                CloseImportModal();
            }
            else
            {
                importErrorMessage = "No content (headings, paragraphs, or images) could be found at the specified URL.";
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to import from URL {Url}", urlToImport);
            importErrorMessage = $"Failed to import content. Error: {ex.Message}";
        }
        finally
        {
            isImporting = false;
            StateHasChanged();
        }
    }
}
