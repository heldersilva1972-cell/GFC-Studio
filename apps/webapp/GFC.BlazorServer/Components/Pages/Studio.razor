@page "/studio/{PageId:int}"
@using System.Text.Json
@using GFC.Core.Models
@using GFC.Core.Interfaces
@using GFC.BlazorServer.Services
@using GFC.BlazorServer.Components.Shared
@inject IJSRuntime JSRuntime
@inject IStudioService StudioService
@inject ITemplateService TemplateService
@inject ILogger<Studio> Logger
@inject NavigationManager NavigationManager
@inject IAuthorizationService AuthorizationService
@inject AuthenticationStateProvider AuthenticationStateProvider
@implements IDisposable

<div class="studio-container">
    @if (isLocked)
    {
        <div class="alert alert-warning m-3">
            <h4>Page Locked</h4>
            <p>This page is currently being edited by <strong>@lockedBy</strong>.</p>
            @if (canForceUnlock)
            {
                <button class="btn btn-danger" @onclick="ForceUnlock">Force Unlock</button>
            }
        </div>
    }
    else
    {
        <div class="top-command-bar">
        <PageNavigator CurrentPageId="PageId" />
        <span class="save-status">@saveStatus</span>
        <button class="btn btn-primary" @onclick="AddSection">Add Section</button>
        <button class="btn btn-info" @onclick="OpenPublishWizard">Publish</button>
        @if (allPages.FirstOrDefault(p => p.Id == PageId)?.IsPublished ?? false)
        {
            <button class="btn btn-warning" @onclick="UnpublishPage">Unpublish</button>
        }
        <button class="btn btn-secondary" @onclick="ToggleVersionHistory">Version History</button>
        @if (wizardWarnings.Any())
        {
            <span class="badge bg-warning text-dark ms-3">@wizardWarnings.Count Wizard Warnings</span>
        }
        <div class="viewport-toggle">
            <button class="btn @(currentViewport == "desktop" ? "btn-secondary" : "btn-outline-secondary")" @onclick='() => setViewport("desktop")'>Desktop</button>
            <button class="btn @(currentViewport == "tablet" ? "btn-secondary" : "btn-outline-secondary")" @onclick='() => setViewport("tablet")'>Tablet</button>
            <button class="btn @(currentViewport == "mobile" ? "btn-secondary" : "btn-outline-secondary")" @onclick='() => setViewport("mobile")'>Mobile</button>
        </div>
    </div>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger m-3">
            <h4>Error Loading Studio</h4>
            <p>@errorMessage</p>
            <pre>@errorDetails</pre>
        </div>
    }

    <div class="studio-workspace">
        @if (showVersionHistory)
        {
            <VersionHistorySidebar Versions="draftHistory" OnPreview="PreviewVersion" OnRestore="RestoreVersion" OnNameVersion="NameVersion" />
        }
        <div class="left-toolbox">
            <div class="toolbox-tabs">
                <button class="tab-button @(activeToolboxTab == "templates" ? "active" : "")" @onclick='() => activeToolboxTab = "templates"'>Templates</button>
                <button class="tab-button @(activeToolboxTab == "elements" ? "active" : "")" @onclick='() => activeToolboxTab = "elements"'>Elements</button>
            </div>
            <div class="toolbox-content">
                @if (activeToolboxTab == "templates")
                {
                    <div class="template-filter mb-2">
                        <select class="form-control form-control-sm" @onchange="FilterTemplates">
                            <option value="">All Categories</option>
                            @foreach (var category in templateCategories)
                            {
                                <option value="@category">@category</option>
                            }
                        </select>
                    </div>
                    <div class="template-list">
                        @foreach (var template in filteredTemplates)
                        {
                            <div class="template-item" draggable="true" @ondragstart="@(() => HandleDragStart(template))">
                                <img src="@(template.ThumbnailUrl ?? "https://via.placeholder.com/300x150?text=" + template.Category)" alt="@template.Name" class="template-thumb" />
                                <div class="template-name">@template.Name</div>
                                <button class="btn btn-sm btn-danger template-delete-btn" @onclick="() => DeleteTemplate(template.Id)">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        }
                    </div>
                }
                @if (activeToolboxTab == "elements")
                {
                    <p>Elements toolbox coming soon!</p>
                }
            </div>
        </div>
        <div class="canvas-container @($"viewport-{currentViewport}")">
            <div class="center-canvas" @ondrop="HandleDrop" @ondragover:preventDefault="true">
                @foreach (var item in sections)
                {
                    <div class="studio-section @(selectedSection == item ? "selected" : "")" data-id="@item.ClientId" @onclick="() => SelectSection(item)">
                        <div class="section-toolbar">
                            <button class="btn btn-sm btn-outline-light" @onclick="() => OpenSaveAsTemplateModal(item)">Save as Template</button>
                        </div>
                        <p contenteditable="true" @oninput="(e) => { item.Content = e.Value.ToString(); MarkAsDirty(); }">@item.Content</p>
                    </div>
                }
            </div>
        </div>
        <div class="right-inspector">
            <StudioWizard @ref="studioWizard" TargetSection="selectedSection" OnContentFixed="@(args => HandleContentFixed(args.newContent, args.fixName))" />
            @if (!string.IsNullOrEmpty(lastWizardAction))
            {
                <button class="btn btn-sm btn-link" @onclick="UndoLastAction">Undo "@lastWizardAction"</button>
            }
        </div>
    </div>
    <div class="animation-orchestrator">
        @if (selectedSection != null)
        {
            <h5>Animation Timeline for: "@selectedSection.Title"</h5>
            <div class="timeline-bar" @ref="_timelineElement">
                @for (int i = 0; i <= 5; i++)
                {
                    <div class="time-marker">@i</div>
                }
                @foreach (var keyframe in currentAnimationKeyframes)
                {
                    <div class="animation-block" style="@GetAnimationBlockStyle(keyframe)" id="@keyframe.Id">
                        @keyframe.Effect
                    </div>
                }
            </div>
            <div class="keyframe-editor mt-3">
                @foreach (var keyframe in currentAnimationKeyframes)
                {
                    <div class="keyframe-controls" id="@keyframe.Id">
                         <select class="form-control form-control-sm" @bind="keyframe.Effect" @onchange="MarkAsDirty">
                            <option value="fadeIn">Fade In</option>
                            <option value="slideInUp">Slide Up</option>
                            <option value="bounceIn">Bounce In</option>
                        </select>
                        <label>D:</label>
                        <input type="range" class="form-control-range" min="0.1" max="5" step="0.1" @bind="keyframe.Duration" @oninput="MarkAsDirty"/>
                        <span>@keyframe.Duration.ToString("0.0")s</span>
                        <label>W:</label>
                        <input type="range" class="form-control-range" min="0" max="5" step="0.1" @bind="keyframe.Delay" @oninput="MarkAsDirty"/>
                        <span>@keyframe.Delay.ToString("0.0")s</span>
                        <button class="btn btn-sm btn-danger" @onclick="() => RemoveKeyframe(keyframe.Id)">X</button>
                    </div>
                }
                <button class="btn btn-sm btn-info" @onclick="AddKeyframe">+ Add Keyframe</button>
            </div>
            <div class="mt-2">
                <button class="btn btn-primary" @onclick="PreviewAnimation">â–¶ Preview</button>
            </div>
        }
        else
        {
            <p class="text-muted">Select a section to configure its animation timeline.</p>
        }
    </div>
</div>

@if (showSaveAsTemplateModal)
{
    <div class="modal fade show" style="display: block;" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Save Section as Template</h5>
                    <button type="button" class="close" @onclick="CloseSaveAsTemplateModal">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="templateName">Template Name</label>
                        <input type="text" class="form-control" id="templateName" @bind="newTemplateName" />
                    </div>
                    <div class="form-group">
                        <label for="templateCategory">Category</label>
                        <input type="text" class="form-control" id="templateCategory" @bind="newTemplateCategory" />
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="CloseSaveAsTemplateModal">Close</button>
                    <button type="button" class="btn btn-primary" @onclick="SaveTemplate">Save Template</button>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-backdrop fade show"></div>
}
}

@if (showPublishingWizard)
{
    <PublishingWizard Page="allPages.FirstOrDefault(p => p.Id == PageId)" OnCancel="() => showPublishingWizard = false" OnConfirm="HandlePublish" />
}

@code {
    [Parameter]
    public int PageId { get; set; }

    private StudioDraft draft;
    private List<StudioPage> allPages = new();
    private List<StudioSection> sections = new();
    private StudioSection selectedSection;
    private List<StudioTemplate> templates = new();
    private List<StudioTemplate> filteredTemplates = new();
    private List<string> templateCategories = new();
    private string selectedTemplateCategory = "";
    private string activeToolboxTab = "templates";
    private StudioSection sectionToSave;
    private bool showSaveAsTemplateModal = false;
    private string newTemplateName = "";
    private string newTemplateCategory = "";
    private string lastWizardAction = "";
    private bool showHistory = false;
    private bool showVersionHistory = false;
    private List<StudioDraft> draftHistory = new();
    private StudioSection lastUndoState;
    private StudioTemplate draggedTemplate;
    private List<AnimationKeyframe> currentAnimationKeyframes = new();
    private StudioWizard studioWizard;
    private List<StudioWizard.WizardWarning> wizardWarnings = new();
    private ElementReference _timelineElement;
    private Timer autoSaveTimer;
    private bool isDirty = false;
    private string saveStatus = "All changes saved";
    private bool isLocked = false;
    private string lockedBy = "";
    private bool canForceUnlock = false;
    private bool showPublishingWizard = false;

    protected override void OnInitialized()
    {
        autoSaveTimer = new Timer(AutoSave, null, Timeout.Infinite, Timeout.Infinite);
    }

    protected override void OnParametersSet()
    {
        if (studioWizard != null)
        {
            wizardWarnings = studioWizard.Warnings;
        }
    }

    private void MarkAsDirty()
    {
        isDirty = true;
        saveStatus = "Saving...";
        autoSaveTimer.Change(2000, Timeout.Infinite); // Debounce for 2 seconds
        InvokeAsync(StateHasChanged);
    }

    private void HandleContentFixed(string newContent, string fixName)
    {
        if (selectedSection != null)
        {
            lastUndoState = new StudioSection { Content = selectedSection.Content };
            selectedSection.Content = newContent;
            lastWizardAction = $"Auto-Fix: {fixName}";
            MarkAsDirty();
            StateHasChanged();
        }
    }

    private void UndoLastAction()
    {
        if (selectedSection != null && lastUndoState != null)
        {
            selectedSection.Content = lastUndoState.Content;
            selectedSection.AnimationSettings = lastUndoState.AnimationSettings;
            lastWizardAction = "";
            lastUndoState = null;
            MarkAsDirty();
            StateHasChanged();
        }
    }

    public class AnimationKeyframe
    {
        public Guid Id { get; set; } = Guid.NewGuid();
        public string Effect { get; set; } = "fadeIn";
        public double Duration { get; set; } = 1.0;
        public double Delay { get; set; } = 0.0;
    }

    private void ToggleHistory() => showHistory = !showHistory;

    private void ToggleVersionHistory() => showVersionHistory = !showVersionHistory;

    private async Task PreviewVersion(StudioDraft version)
    {
        // For now, preview will just load the draft into a separate, temporary state.
        // A full implementation would render this in the iframe without touching the editor state.
        var previewSections = JsonSerializer.Deserialize<List<StudioSection>>(version.ContentJson);
        // This is a simplified preview. In a real app, you'd send this to the iframe via JS interop.
        await JSRuntime.InvokeVoidAsync("updatePreview", previewSections);
    }

    private async Task RestoreVersion(StudioDraft version)
    {
        await LoadDraft(version);
        MarkAsDirty();
    }

    private async Task NameVersion(string name)
    {
        if (draft != null && !string.IsNullOrWhiteSpace(name))
        {
            await StudioService.NameDraftAsync(draft.Id, name);
            await LoadHistory();
        }
    }

    private void SelectSection(StudioSection section)
    {
        selectedSection = section;
        if (!string.IsNullOrEmpty(selectedSection.AnimationSettings))
        {
            try
            {
                currentAnimationKeyframes = JsonSerializer.Deserialize<List<AnimationKeyframe>>(selectedSection.AnimationSettings) ?? new List<AnimationKeyframe>();
            }
            catch
            {
                currentAnimationKeyframes = new List<AnimationKeyframe>();
            }
        }
        else
        {
            currentAnimationKeyframes = new List<AnimationKeyframe>();
        }

        if (!currentAnimationKeyframes.Any())
        {
            currentAnimationKeyframes.Add(new AnimationKeyframe());
        }
    }

    private async Task LoadDraft(StudioDraft selectedDraft)
    {
        draft = selectedDraft;
        if (!string.IsNullOrEmpty(draft.ContentJson))
        {
            sections = JsonSerializer.Deserialize<List<StudioSection>>(draft.ContentJson);
        }
        showHistory = false;
        StateHasChanged();
    }

    private async Task PreviewAnimation()
    {
        if (selectedSection != null)
        {
            await JSRuntime.InvokeVoidAsync("previewAnimation", selectedSection.ClientId, currentAnimationKeyframes);
        }
    }

    private void AddKeyframe()
    {
        currentAnimationKeyframes.Add(new AnimationKeyframe { Delay = currentAnimationKeyframes.LastOrDefault()?.Delay + currentAnimationKeyframes.LastOrDefault()?.Duration ?? 0 });
        MarkAsDirty();
    }

    private void RemoveKeyframe(Guid id)
    {
        var keyframe = currentAnimationKeyframes.FirstOrDefault(k => k.Id == id);
        if (keyframe != null)
        {
            currentAnimationKeyframes.Remove(keyframe);
            MarkAsDirty();
        }
    }

    private string GetAnimationBlockStyle(AnimationKeyframe keyframe)
    {
        // Assuming timeline is 5s long and 100% width. Each second is 20%.
        var left = keyframe.Delay * 20;
        var width = keyframe.Duration * 20;
        return $"left: {left}%; width: {width}%;";
    }

    private void HandleDragStart(StudioTemplate template)
    {
        draggedTemplate = template;
    }

    private void HandleDrop()
    {
        if (draggedTemplate != null)
        {
            var newSection = JsonSerializer.Deserialize<StudioSection>(draggedTemplate.ContentJson);
            newSection.ClientId = Guid.NewGuid();
            newSection.StudioPageId = PageId;
            newSection.PageIndex = sections.Count;
            sections.Add(newSection);
            draggedTemplate = null;
            MarkAsDirty();
        }
    }

    private void OpenSaveAsTemplateModal(StudioSection section)
    {
        sectionToSave = section;
        newTemplateName = section.Title;
        newTemplateCategory = "General";
        showSaveAsTemplateModal = true;
    }

    private void CloseSaveAsTemplateModal()
    {
        showSaveAsTemplateModal = false;
        sectionToSave = null;
        newTemplateName = "";
        newTemplateCategory = "";
    }

    private async Task SaveTemplate()
    {
        if (sectionToSave != null && !string.IsNullOrWhiteSpace(newTemplateName) && !string.IsNullOrWhiteSpace(newTemplateCategory))
        {
            var newTemplate = new StudioTemplate
            {
                Name = newTemplateName,
                Category = newTemplateCategory,
                ContentJson = JsonSerializer.Serialize(sectionToSave)
            };
            await TemplateService.CreateTemplateAsync(newTemplate);
            await LoadTemplates();
            CloseSaveAsTemplateModal();
        }
    }
    private string currentViewport = "desktop";
    private string errorMessage;
    private string errorDetails;

    private async Task LoadTemplates()
    {
        templates = await TemplateService.GetAllTemplatesAsync();
        templateCategories = templates.Select(t => t.Category).Distinct().OrderBy(c => c).ToList();
        FilterTemplates(new ChangeEventArgs { Value = "" });
    }

    private void FilterTemplates(ChangeEventArgs e)
    {
        selectedTemplateCategory = e.Value.ToString();
        if (string.IsNullOrEmpty(selectedTemplateCategory))
        {
            filteredTemplates = templates;
        }
        else
        {
            filteredTemplates = templates.Where(t => t.Category == selectedTemplateCategory).ToList();
        }
    }

    private async Task DeleteTemplate(int id)
    {
        await TemplateService.DeleteTemplateAsync(id);
        await LoadTemplates();
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            if (PageId == 0)
            {
                errorMessage = "No page specified. Please select a page to edit.";
                return;
            }

            var lockResult = await StudioService.AcquireLockAsync(PageId, "System"); // TODO: Use real user
            if (!lockResult)
            {
                var currentLock = await StudioService.GetLockAsync(PageId);
                isLocked = true;
                lockedBy = currentLock?.LockedBy ?? "another user";

                var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                var user = authState.User;
                canForceUnlock = (await AuthorizationService.AuthorizeAsync(user, AppPolicies.CanForceUnlock)).Succeeded;

                return;
            }

            draft = await StudioService.GetLatestDraftAsync(PageId);

            if (draft != null && !string.IsNullOrEmpty(draft.ContentJson))
            {
                sections = JsonSerializer.Deserialize<List<StudioSection>>(draft.ContentJson) ?? new List<StudioSection>();
            }
            else
            {
                sections = new List<StudioSection>();
            }

            await LoadHistory();
            await LoadTemplates();
            allPages = (await StudioService.GetAllPagesAsync()).ToList();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize Studio");
            errorMessage = ex.Message;
            errorDetails = ex.ToString();
        }
    }

    private void setViewport(string viewport)
    {
        currentViewport = viewport;
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && string.IsNullOrEmpty(errorMessage))
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("initializeDnd", DotNetObjectReference.Create(this));
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to initialize Drag and Drop");
            }
        }
        if (selectedSection != null)
        {
            await JSRuntime.InvokeVoidAsync("initializeTimeline", _timelineElement, DotNetObjectReference.Create(this));
        }
    }

    [JSInvokable]
    public void UpdateKeyframe(string keyframeId, double newDuration, double newDelay)
    {
        var keyframe = currentAnimationKeyframes.FirstOrDefault(k => k.Id == Guid.Parse(keyframeId));
        if (keyframe != null)
        {
            keyframe.Duration = newDuration;
            keyframe.Delay = newDelay;
            StateHasChanged();
        }
    }

    private async Task LoadHistory()
    {
        draftHistory = (await StudioService.GetDraftHistoryAsync(PageId)).ToList();
    }

    private async Task SaveDraft()
    {
        try
        {
            if (selectedSection != null)
            {
                selectedSection.AnimationSettings = JsonSerializer.Serialize(currentAnimationKeyframes);
            }
            
            var json = JsonSerializer.Serialize(sections);
            draft = await StudioService.SaveDraftAsync(PageId, json, "System"); // TODO: Use real user
            
            await LoadHistory();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save draft");
            errorMessage = "Failed to save draft: " + ex.Message;
        }
    }

    private void OpenPublishWizard()
    {
        showPublishingWizard = true;
    }

    private async Task HandlePublish(string notes)
    {
        try
        {
            if (draft == null || draft.Id == 0)
            {
                // Auto-save before publishing
                await SaveDraft();
            }
            
            if (draft != null)
            {
                await StudioService.PublishDraftAsync(draft.Id);
                showPublishingWizard = false;
                // In a real app, you would also trigger the Next.js cache purge here.
                // For now, we'll just log it.
                Logger.LogInformation("Page published! Cache purge would be triggered for page: {PageSlug}", allPages.FirstOrDefault(p => p.Id == PageId)?.Slug);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to publish page");
            errorMessage = "Failed to publish page: " + ex.Message;
        }
    }

    private async Task UnpublishPage()
    {
        try
        {
            await StudioService.UnpublishPageAsync(PageId);
            // In a real app, you would also trigger the Next.js cache purge here.
            Logger.LogInformation("Page unpublished! Cache purge would be triggered for page: {PageSlug}", allPages.FirstOrDefault(p => p.Id == PageId)?.Slug);
            await OnInitializedAsync(); // Refresh page state
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to unpublish page");
            errorMessage = "Failed to unpublish page: " + ex.Message;
        }
    }


    private void AddSection()
    {
        var newSection = new StudioSection
        {
            ClientId = Guid.NewGuid(),
            Title = "New Section",
            Content = "New Section",
            PageIndex = sections.Count,
            StudioPageId = PageId,
        };
        sections.Add(newSection);
        MarkAsDirty();
    }

    [JSInvokable]
    public void UpdateSectionOrder(string[] clientIds)
    {
        var newSections = new List<StudioSection>();
        foreach (var id in clientIds)
        {
            var section = sections.First(s => s.ClientId == Guid.Parse(id));
            section.PageIndex = newSections.Count;
            newSections.Add(section);
        }
        sections = newSections;
        MarkAsDirty();
        StateHasChanged();
    }

    private async void AutoSave(object state)
    {
        if (!isDirty) return;

        await InvokeAsync(async () =>
        {
            try
            {
                if (selectedSection != null)
                {
                    selectedSection.AnimationSettings = JsonSerializer.Serialize(currentAnimationKeyframes);
                }

                var json = JsonSerializer.Serialize(sections);
                draft = await StudioService.SaveDraftAsync(PageId, json, "System"); // TODO: Use real user

                await LoadHistory();
                isDirty = false;
                saveStatus = "All changes saved";
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to auto-save draft");
                saveStatus = "Error saving!";
            }
        });
    }

    public void Dispose()
    {
        if (!isLocked)
        {
            InvokeAsync(() => StudioService.ReleaseLockAsync(PageId, "System")); // TODO: Use real user
        }
        autoSaveTimer?.Dispose();
    }

    private async Task ForceUnlock()
    {
        await StudioService.ForceReleaseLockAsync(PageId);
        isLocked = false;
        await OnInitializedAsync();
        StateHasChanged();
    }
}
