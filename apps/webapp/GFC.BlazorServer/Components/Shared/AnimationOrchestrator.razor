// [MODIFIED]
@using System.Text.Json
@using GFC.Core.Models
@using Microsoft.AspNetCore.SignalR.Client
@using System.Threading
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@implements IAsyncDisposable

@if (TargetSection != null)
{
<div class="animation-orchestrator-panel-container">
    <div class="timeline-section">
        <div class="panel-toolbar">
            <button class="btn btn-sm btn-light" @onclick="PlayAnimation">▶ Play</button>
            <button class="btn btn-sm btn-light" @onclick="PauseAnimation">⏸ Pause</button>
            <span class="time-display">@currentTime.ToString("0.00")s</span>

            <div class="add-animation-controls ms-4">
                <select class="form-select form-select-sm d-inline-block w-auto" @bind="selectedLayerForAdd">
                    @foreach(var layer in animatableLayers)
                    {
                        <option value="@layer">@layer</option>
                    }
                </select>
                <button class="btn btn-sm btn-success" @onclick="AddKeyframe">Add Animation</button>
                <button class="btn btn-sm btn-danger" @onclick="RemoveSelectedKeyframe" disabled="@(selectedKeyframe == null)">Remove</button>
            </div>
        </div>
        <div class="timeline-container" @ref="timelineContainerElement">
            <div class="time-ruler">
                @for (int i = 0; i <= 10; i++)
                {
                    <div class="time-marker" style="left: @(i * 10)%;">@i s</div>
                }
            </div>
            <div @ref="playheadElement" class="playhead" style="left: @(playheadPosition)%;"></div>
            <div class="layers-container">
                @foreach (var layer in animatableLayers)
                {
                    <div class="animation-layer">
                        <div class="layer-header">@layer</div>
                        <div class="layer-timeline">
                            @foreach (var keyframe in GetKeyframesForLayer(layer))
                            {
                                <div class="motion-bar @(selectedKeyframe == keyframe ? "selected" : "")"
                                     style="@GetMotionBarStyle(keyframe)"
                                     data-id="@keyframe.Id"
                                     @onclick="() => SelectKeyframe(keyframe)">
                                    @keyframe.Effect
                                </div>
                            }
                        </div>
                    </div>
                }
            </div>
        </div>
    </div>
    <div class="editor-section">
        <TransitionEditor SelectedKeyframe="selectedKeyframe" OnKeyframeChanged="NotifyChanges" />
    </div>
</div>
}

@code {
    [Parameter]
    public StudioSection TargetSection { get; set; }

    [Parameter]
    public EventCallback<string> OnAnimationSettingsChanged { get; set; }

    private List<AnimationKeyframe> keyframes = new();
    private AnimationKeyframe selectedKeyframe;
    private List<string> animatableLayers = new List<string> { "Title", "Subtitle", "Image", "Button" };
    private string selectedLayerForAdd = "Title";
    private double currentTime = 0.0;
    private string playheadPosition = "0";

    private ElementReference timelineContainerElement;
    private ElementReference playheadElement;
    private DotNetObjectReference<AnimationOrchestrator> dotNetHelper;
    private HubConnection hubConnection;
    private Timer animationTimer;

    protected override async Task OnInitializedAsync()
    {
        dotNetHelper = DotNetObjectReference.Create(this);
        var hubUrl = NavigationManager.ToAbsoluteUri("/animationhub");
        hubConnection = new HubConnectionBuilder()
            .WithUrl(hubUrl)
            .Build();

        await hubConnection.StartAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && TargetSection != null)
        {
            await JSRuntime.InvokeVoidAsync("initializeAnimationOrchestrator", timelineContainerElement, playheadElement, dotNetHelper);
        }
    }

    private async Task NotifyChanges()
    {
        var json = JsonSerializer.Serialize(keyframes);
        await OnAnimationSettingsChanged.InvokeAsync(json);
        await SendAnimationUpdate();
    }

    private async void AddKeyframe()
    {
        var newKeyframe = new AnimationKeyframe
        {
            Target = selectedLayerForAdd,
            Effect = "fadeIn",
            Duration = 1,
            Delay = currentTime
        };
        keyframes.Add(newKeyframe);
        await SelectKeyframe(newKeyframe);
        await NotifyChanges();
    }

    private async void RemoveSelectedKeyframe()
    {
        if (selectedKeyframe != null)
        {
            keyframes.Remove(selectedKeyframe);
            selectedKeyframe = null;
            await NotifyChanges();
        }
    }

    private async Task SelectKeyframe(AnimationKeyframe keyframe)
    {
        selectedKeyframe = keyframe;
        await SendAnimationUpdate();
        StateHasChanged();
    }

    [JSInvokable]
    public async Task UpdateKeyframeTiming(string keyframeId, double delay, double duration)
    {
        var keyframe = keyframes.FirstOrDefault(k => k.Id.ToString() == keyframeId);
        if (keyframe != null)
        {
            keyframe.Delay = Math.Round(delay, 2);
            keyframe.Duration = Math.Round(duration, 2);
            await NotifyChanges();
            StateHasChanged();
        }
    }

    private void PlayAnimation()
    {
        if (animationTimer == null)
        {
            animationTimer = new Timer(async _ =>
            {
                currentTime += 0.05; // 20fps
                if (currentTime > 10)
                {
                    currentTime = 0;
                }
                await SetCurrentTime(currentTime);
                await InvokeAsync(StateHasChanged);
            }, null, 0, 50);
        }
    }

    private void PauseAnimation()
    {
        animationTimer?.Dispose();
        animationTimer = null;
    }

    [JSInvokable]
    public async Task SetCurrentTime(double time)
    {
        currentTime = time;
        playheadPosition = ((currentTime / 10.0) * 100).ToString("F2");
        await SendAnimationUpdate();
    }

    private async Task SendAnimationUpdate()
    {
        if (hubConnection is not null)
        {
            await hubConnection.SendAsync("SendAnimationUpdate", keyframes, currentTime);
        }
    }

    protected override void OnParametersSet()
    {
        if (TargetSection != null && !string.IsNullOrEmpty(TargetSection.AnimationSettings))
        {
            keyframes = JsonSerializer.Deserialize<List<AnimationKeyframe>>(TargetSection.AnimationSettings) ?? new List<AnimationKeyframe>();
        }
        else
        {
            keyframes = new List<AnimationKeyframe>();
        }
    }

    private IEnumerable<AnimationKeyframe> GetKeyframesForLayer(string layerName)
    {
        return keyframes.Where(k => k.Target.Equals(layerName, StringComparison.OrdinalIgnoreCase));
    }

    private string GetMotionBarStyle(AnimationKeyframe keyframe)
    {
        var left = (keyframe.Delay / 10.0) * 100;
        var width = (keyframe.Duration / 10.0) * 100;
        return $"left: {left.ToString("F2")}%; width: {width.ToString("F2")}%;";
    }

    public async ValueTask DisposeAsync()
    {
        dotNetHelper?.Dispose();
        animationTimer?.Dispose();
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
        if (JSRuntime is not null)
        {
            await JSRuntime.InvokeVoidAsync("destroyAnimationOrchestrator");
        }
    }
}
