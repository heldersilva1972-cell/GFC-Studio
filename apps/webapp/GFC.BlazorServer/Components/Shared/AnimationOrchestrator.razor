@using System.Text.Json
@using GFC.Core.Models
@using System.Threading
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

@if (Keyframes != null && Keyframes.Any())
{
    <div class="animation-orchestrator-panel-container">
        <div class="timeline-section">
            <div class="panel-toolbar">
                <button class="btn btn-sm btn-light" @onclick="PlayAnimation">▶ Play</button>
                <button class="btn btn-sm btn-light" @onclick="PauseAnimation">⏸ Pause</button>
                <span class="time-display">@currentTime.ToString("0.00")s</span>

                <div class="add-animation-controls ms-4">
                    <select class="form-select form-select-sm d-inline-block w-auto" @bind="selectedLayerForAdd">
                        @foreach(var layer in animatableLayers)
                        {
                            <option value="@layer">@layer</option>
                        }
                    </select>
                    <button class="btn btn-sm btn-success" @onclick="AddKeyframe">Add Keyframe</button>
                    <button class="btn btn-sm btn-danger" @onclick="RemoveSelectedKeyframe" disabled="@(selectedKeyframe == null)">Remove</button>
                </div>
            </div>
            <div class="timeline-container" @ref="timelineContainerElement">
                <div class="time-ruler">
                    @for (int i = 0; i <= 10; i++)
                    {
                        <div class="time-marker" style="left: @(i * 10)%;">@i s</div>
                    }
                </div>
                <div @ref="playheadElement" class="playhead" style="left: @(playheadPosition)%;"></div>
                <div class="layers-container">
                    @foreach (var layer in animatableLayers)
                    {
                        <div class="animation-layer">
                            <div class="layer-header">@layer</div>
                            <div class="layer-timeline">
                                @foreach (var keyframe in GetKeyframesForLayer(layer))
                                {
                                    <div class="motion-bar @(selectedKeyframe == keyframe ? "selected" : "")"
                                         style="@GetMotionBarStyle(keyframe)"
                                         data-id="@keyframe.Id"
                                         @onclick="() => SelectKeyframe(keyframe)">
                                        @keyframe.Effect
                                    </div>
                                }
                            </div>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>
}
else
{
    <div class="placeholder-text">
        <p>Load an animation from the library to begin.</p>
    </div>
}


@code {
    [Parameter]
    public List<AnimationKeyframe> Keyframes { get; set; } = new();

    [Parameter]
    public EventCallback<AnimationKeyframe> OnKeyframeSelected { get; set; }

    [Parameter]
    public EventCallback OnAnimationChanged { get; set; }

    [Parameter]
    public EventCallback<double> OnTimeChanged { get; set; }

    private AnimationKeyframe selectedKeyframe;
    private List<string> animatableLayers = new List<string> { "Element", "Title", "Subtitle", "Image", "Button" };
    private string selectedLayerForAdd = "Element";
    private double currentTime = 0.0;
    private string playheadPosition = "0";

    private ElementReference timelineContainerElement;
    private ElementReference playheadElement;
    private DotNetObjectReference<AnimationOrchestrator> dotNetHelper;
    private Timer animationTimer;

    protected override void OnInitialized()
    {
        dotNetHelper = DotNetObjectReference.Create(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && Keyframes != null && Keyframes.Any())
        {
            await JSRuntime.InvokeVoidAsync("initializeAnimationOrchestrator", timelineContainerElement, playheadElement, dotNetHelper);
        }
    }

    private async Task NotifyChanges()
    {
        await OnAnimationChanged.InvokeAsync();
    }

    private async void AddKeyframe()
    {
        var newKeyframe = new AnimationKeyframe
        {
            Id = Guid.NewGuid(),
            Target = selectedLayerForAdd,
            Effect = "fadeIn",
            Duration = 1,
            Delay = currentTime
        };
        Keyframes.Add(newKeyframe);
        await SelectKeyframe(newKeyframe);
        await NotifyChanges();
    }

    private async void RemoveSelectedKeyframe()
    {
        if (selectedKeyframe != null)
        {
            Keyframes.Remove(selectedKeyframe);
            selectedKeyframe = null;
            await OnKeyframeSelected.InvokeAsync(null);
            await NotifyChanges();
        }
    }

    private async Task SelectKeyframe(AnimationKeyframe keyframe)
    {
        selectedKeyframe = keyframe;
        await OnKeyframeSelected.InvokeAsync(keyframe);
        StateHasChanged();
    }

    [JSInvokable]
    public async Task UpdateKeyframeTiming(string keyframeId, double delay, double duration)
    {
        var keyframe = Keyframes.FirstOrDefault(k => k.Id.ToString() == keyframeId);
        if (keyframe != null)
        {
            keyframe.Delay = Math.Round(delay, 2);
            keyframe.Duration = Math.Round(duration, 2);
            await NotifyChanges();
            StateHasChanged();
        }
    }

    private void PlayAnimation()
    {
        if (animationTimer == null)
        {
            animationTimer = new Timer(async _ =>
            {
                currentTime += 0.05;
                if (currentTime > 10)
                {
                    currentTime = 0;
                }
                await SetCurrentTime(currentTime);
                await InvokeAsync(StateHasChanged);
            }, null, 0, 50);
        }
    }

    private void PauseAnimation()
    {
        animationTimer?.Dispose();
        animationTimer = null;
    }

    [JSInvokable]
    public async Task SetCurrentTime(double time)
    {
        currentTime = time;
        playheadPosition = ((currentTime / 10.0) * 100).ToString("F2", System.Globalization.CultureInfo.InvariantCulture);
        await OnTimeChanged.InvokeAsync(currentTime);
    }

    protected override void OnParametersSet()
    {
        if (selectedKeyframe != null && !Keyframes.Contains(selectedKeyframe))
        {
            selectedKeyframe = null;
        }
    }

    private IEnumerable<AnimationKeyframe> GetKeyframesForLayer(string layerName)
    {
        return Keyframes.Where(k => k.Target.Equals(layerName, StringComparison.OrdinalIgnoreCase));
    }

    private string GetMotionBarStyle(AnimationKeyframe keyframe)
    {
        var left = (keyframe.Delay / 10.0) * 100;
        var width = (keyframe.Duration / 10.0) * 100;
        return $"left: {left.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)}%; width: {width.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)}%;";
    }

    public async ValueTask DisposeAsync()
    {
        dotNetHelper?.Dispose();
        animationTimer?.Dispose();
        if (JSRuntime is not null)
        {
            _ = JSRuntime.InvokeVoidAsync("destroyAnimationOrchestrator");
        }
    }
}
