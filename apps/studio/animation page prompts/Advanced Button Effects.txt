PROJECT: Animation Playground (standalone project)
PHASE: 5.xC – Advanced Button Effects (20 total)
REV: 1.0 – 2025-11-28

GOAL
Add a new "Buttons" animation category with 20 high-end advanced button effects, fully integrated into the existing Animation Playground infrastructure. Do NOT remove or alter any existing animations from previous phases (including 5.xB and 5.xA). This phase is additive only.

GLOBAL RULES
- Tech stack: Next.js (App Router), React, TypeScript, Tailwind CSS, Framer Motion.
- Do NOT change the project structure except where explicitly requested.
- Do NOT remove or rename existing animations, registry entries, or categories.
- Keep everything idempotent: re-running this phase must not break anything.
- Prefer small, focused components + a shared base for consistency.
- No placeholder TODOs; implement all behaviors fully.

STEP 1 – DISCOVER CURRENT ANIMATION INFRA
1. Scan the project for:
   - The central animation registry (array/object that lists all animations with fields like id, name, description, category, etc.).
   - The animation type/interface used for registry entries (e.g., AnimationDefinition or similar).
   - The UI layer that:
     - Renders the category filter buttons (e.g., "All", "Text", "Shapes", etc.).
     - Renders the tile grid and selection.
     - Renders the currently selected animation in the preview viewer.
2. DO NOT change how the registry is consumed. Instead, extend it following the exact same patterns (types, imports, exports, naming).
3. Identify how categories are defined:
   - If categories are strings on each registry item, keep that pattern.
   - If there is a central list/enum of categories, extend it with a "Buttons" category.

STEP 2 – ADD "Buttons" CATEGORY
1. Introduce a new category named exactly: "Buttons".
   - If categories are an enum or union type, add "Buttons" there.
   - If categories are dynamic (string field only), ensure every new animation uses category: "Buttons".
2. Ensure the UI’s category filter includes a visible tile/button for "Buttons" alongside the existing categories.
   - Selecting "Buttons" must filter the grid to only show these 20 button animations.
   - Selecting "All" must include these 20 along with all prior animations.
3. Do not change behavior for existing categories.

STEP 3 – CREATE A SHARED BUTTON EFFECT BASE COMPONENT
1. Create a reusable base component, e.g.:
   - Path suggestion (adapt to current structure): `components/animations/buttons/ButtonEffectBase.tsx`
   - Name: `ButtonEffectBase`
2. Purpose:
   - Provide a consistent layout for an animated button:
     - Centered in the preview area.
     - Responsive; looks good on desktop and tablet.
     - Clear label text that can be passed as props.
   - Encapsulate common styling:
     - Tailwind for base button shape (rounded, padding, font, etc.).
     - Neutral, modern base styles that can be extended with className + children.
   - Provide common props such as:
     - `label: string`
     - `className?: string`
     - `motionProps?: MotionProps` (if useful)
     - `children?: ReactNode` for extra layers (e.g., particles, glows).
3. Integrate Framer Motion:
   - Use `<motion.button>` inside.
   - Provide sensible default hover/tap states that each effect can override/extend as needed.

STEP 4 – IMPLEMENT THE 20 ADVANCED BUTTON EFFECT COMPONENTS
For each effect below:
- Create a separate component in a logical folder, e.g. `components/animations/buttons/`.
- Each component should:
  - Be a named and default export, matching a clear naming convention.
  - Wrap or use `ButtonEffectBase` for layout and core styling.
  - Use Tailwind + Framer Motion for animation logic.
  - Have all hover/click effects fully implemented (no placeholders).
- Use only CSS and Framer Motion (no external animation libs beyond what the project already uses).

1) Liquid Ripple Button
   - Behavior:
     - On click, generate a circular ripple starting at the click position, expanding outward and fading.
   - Implementation details:
     - Use an absolutely-positioned pseudo-layer within the button.
     - On click, spawn an animated circle using Framer Motion (scale + opacity).
     - Support multiple ripples if clicked rapidly.

2) Glass Morph Slide-In Button
   - Behavior:
     - Default: subtle glassmorphism style (transparent + blur + border).
     - Hover: button slides slightly “forward” in Z (scale + translateY), with increased glow/blur.
   - Implementation:
     - Tailwind: backdrop-blur, semi-transparent background, subtle border.
     - Motion: small scale + translateY, plus soft shadow change on hover.

3) Neon Pulse Edge Glow
   - Behavior:
     - Idle: crisp neon border, low-intensity outer glow.
     - Hover: gentle, continuous pulse of glow.
     - Click: quick, stronger pulse “explosion” around the edges.
   - Implementation:
     - Use box-shadow or a wrapping div with animated glow intensity.
     - Framer Motion to animate border/outer glow intensity.

4) Magnetic Attraction Button
   - Behavior:
     - Button subtly moves toward the cursor position while the cursor is near/inside the button area.
     - Click: button snaps to a centered neutral position and briefly scales up then back.
   - Implementation:
     - Use mouse move events within the button to set small x/y offsets on a motion.div.
     - Constrain movement so it does not leave its container.

5) Soft-Body Gooey Button
   - Behavior:
     - Hover: button slightly stretches toward cursor direction.
     - Click: button squishes and rebounds with overshoot (soft-body effect).
   - Implementation:
     - Use a squishy easing curve (spring with low stiffness/high damping).
     - Combine scaleX/scaleY and maybe border-radius animations.

6) Shockwave Click Animation
   - Behavior:
     - On click, emit a circular outline shockwave from center that expands and fades.
   - Implementation:
     - Add an absolutely-positioned circular outline rendered via motion.div.
     - Animate scale + opacity; allow repeated clicks to stack shockwaves.

7) Shimmer Sweep Button
   - Behavior:
     - On hover, a diagonal shimmer/light streak passes across the button.
   - Implementation:
     - Use a pseudo-element or extra div with a gradient stripe.
     - Animate its x-position across the button using Framer Motion.

8) 3D Tilt Parallax Button
   - Behavior:
     - Button tilts in 3D depending on cursor position (parallax effect).
     - On hover exit, smoothly returns to neutral.
   - Implementation:
     - Track mouse position relative to center.
     - Apply small rotateX/rotateY transforms via Framer Motion.

9) Color Bloom Button
   - Behavior:
     - On hover, a blooming color radiates out from cursor position, filling the button background.
     - On hover end, color recedes or transitions back to base.
   - Implementation:
     - Use radial gradient simulated via a positioned div that scales up.
     - Animate background/overlay color and scale.

10) Particle Burst Button
    - Behavior:
      - On click, emit 30–60 small particles (dots or shapes) that fly outward and fade.
    - Implementation:
      - Create a simple particle system using an array of motion.div elements with randomized trajectories.
      - Particles live for a short duration before being removed from state.

11) Laser Beam Border Trace
    - Behavior:
      - On hover, a “laser” line travels around the border of the button in sequence (top → right → bottom → left).
    - Implementation:
      - Use 4 small motion.divs positioned along each edge; animate their length/position in sequence to simulate tracing.

12) Aurora Gradient Button
    - Behavior:
      - Background features slow-moving aurora-like gradient waves, even when idle.
      - Hover subtly intensifies movement and brightness.
    - Implementation:
      - Use a background gradient in a motion.div, animating background-position or gradient stop positions.
      - Keep the animation smooth and slow.

13) Morphing Shape Button
    - Behavior:
      - Idle: standard rounded rectangle.
      - Hover: smoothly morphs between rounded rectangle → fully pill → slightly squashed pill and back.
    - Implementation:
      - Animate border-radius and width/height ratios.
      - Use looped animation while hovered, or one complete morph sequence per hover.

14) Button with Dynamic Shadow
    - Behavior:
      - Shadow direction and length adjust based on cursor position relative to the button center.
      - Click temporarily increases shadow softness and reduces distance (like being “pressed in”).
    - Implementation:
      - Calculate offset from center and map it to shadow x/y.
      - Use motion to animate box-shadow or a pseudo shadow container.

15) Ripple-Inside-Glow Button
    - Behavior:
      - The button has a constant soft glow border.
      - On click, multiple inward concentric ripples appear inside the button, moving inward or pulsing.
    - Implementation:
      - Layer concentric motion.div circles or outlines inside the button.
      - Animate their scale and opacity with staggered timing.

16) Firefly Sparkle Button
    - Behavior:
      - Small glowing “fireflies” wander slowly around/over the button.
      - On hover, they brighten and slightly increase speed.
    - Implementation:
      - Similar to a particle system with looping paths; each firefly has a slow, looping animation.
      - Use small circular elements with blur/opacity animation.

17) Split-Reveal Button
    - Behavior:
      - On hover, the button appears to split into left and right halves that move slightly apart, revealing a glowing inner core between them.
      - On hover end, halves slide back together.
    - Implementation:
      - Internally have two halves (left/right) with content; animate their x positions.
      - Inner glow layer is a motion.div revealed between halves.

18) 3D Pop-Out Layered Button
    - Behavior:
      - Button is composed of multiple layers (background, main face, highlight edge).
      - Hover: layers separate slightly in z (using scale/translate), creating a 3D stack effect.
      - Click: layers compress together then re-expand.
    - Implementation:
      - Use several nested motion.divs with different transforms.

19) Aura Pressure Button
    - Behavior:
      - Idle: subtle outer aura glow.
      - Hover: aura grows a bit in size and intensity.
      - Click: aura compresses inward briefly, then expands outward with a soft fade.
    - Implementation:
      - Outer ring/blur element whose scale/opacity is animated by hover/click state.

20) Holographic Glitch Button
    - Behavior:
      - Periodic subtle glitch effects: text shifts horizontally, RGB channel split, slight distortion.
      - Hover triggers a more visible glitch burst (but still readable).
    - Implementation:
      - Use Framer Motion keyframe animations to offset text and overlay colored duplicates.
      - Ensure legibility; glitch is aesthetic, not destructive.

STEP 5 – REGISTER THE 20 BUTTON EFFECTS IN THE ANIMATION REGISTRY
1. For each button component, add a corresponding entry in the main animation registry.
   - Use a consistent ID pattern, e.g.:
     - "button-liquid-ripple"
     - "button-glass-morph-slide"
     - "button-neon-pulse-glow"
     - "button-magnetic-attraction"
     - "button-soft-body-gooey"
     - "button-shockwave-click"
     - "button-shimmer-sweep"
     - "button-3d-tilt-parallax"
     - "button-color-bloom"
     - "button-particle-burst"
     - "button-laser-border-trace"
     - "button-aurora-gradient"
     - "button-morphing-shape"
     - "button-dynamic-shadow"
     - "button-inner-ripple-glow"
     - "button-firefly-sparkle"
     - "button-split-reveal"
     - "button-3d-pop-out-layers"
     - "button-aura-pressure"
     - "button-holographic-glitch"
   - category: "Buttons"
   - name: short human-readable title (matching descriptions above).
   - description: 1–2 sentence explanation of what the button does.
   - component reference: the React component created for each effect.
   - tags: include keywords like ["button", "hover", "click", "neon", "3d", "particles"] as appropriate.
2. Ensure typing is correct and matches the registry’s existing animation type/interface.
3. Make sure the preview system used by the playground correctly renders these button animations just like existing ones.

STEP 6 – UI INTEGRATION & EXPERIENCE POLISH
1. Confirm that:
   - The "Buttons" category filter works.
   - The tile grid shows all 20 button animations when "Buttons" is selected.
   - Clicking a tile loads the correct button preview in the viewer.
2. Ensure button previews are:
   - Reasonably sized and centered in the preview area.
   - Readable labels (e.g., use a generic label like “Click Me” or “Advanced Button”).
3. Check that none of the new effects introduce layout shifts that affect the overall page (e.g., no full-page scroll jumps when animating).

STEP 7 – CLEANUP & VALIDATION
1. Run TypeScript check and fix any type errors.
2. Run the Next.js dev build to ensure there are no runtime/import errors.
3. Keep all changes scoped to this phase’s purpose:
   - No unrelated refactors.
   - No changes to non-animation features.

DELIVERABLE
A fully working "Buttons" category with 20 advanced button animations, selectable from the Animation Playground UI, each with a correctly registered entry in the animation registry and clean, modern visual behavior as described above.
